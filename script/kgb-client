#!/usr/bin/perl
use utf8;
require v5.10.0;
# vim: ts=4:sw=4:et:ai:sts=4
#
# KGB - an IRC bot helping collaboration
# Copyright © 2008 Martín Ferrari
# Copyright © 2009, 2011, 2012 Damyan Ivanov
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 51
# Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

use strict;
use warnings;

=head1 NAME

kgb-client - relay commits to KGB servers

=head1 SYNOPSIS

=over

=item B<kgb-client> --conf I</path/to/config> [I<other-option> ...]

=item B<kgb-client> --uri I<http://some.server:port/service>
                    --password I<password>
                    --repo-id I<repository>
                    --repository I<svn|git|cvs>
                    --timeout I<timeout-in-seconds>
                    --single-line-commits I<off|forced|auto>
                    --web-link I<template>
                    --short-url-service I<service>
                    --status-dir I<directory>

=item B<kgb-client> I<option>... I</svn/repo> I<revision>

=item B<kgb-client> I<option>... I<old-rev> I<new-rev> I<ref-name>

=item B<kgb-client> I<option>... $CVSROOT "%p"

=item B<kgb-client> I<option>... --fake

=item B<kgb-client> I<option>... --relay-msg I<message>...

=back

=head1 DESCRIPTION

B<kgb-client> is the client counterpart of L<kgb-bot(1)>. It is intended to be
used as a hook in your version control system, executed after the repository
gets updated. It analyzes the commit(s) and then relays the information to the
KGB server, which will show it on IRC.

=head1 CONFIGURATION

=over

=item B<--conf> I<configuration file>

Specifies the path to kgb-client configuration file.

=back

Configuration options (except B<--conf>, B<--fake> and B<--relay-msg>) may be
specified both in the configuration file and on the command line. Usually you
want to have all the
options in a configuration file, because having passwords on the command line
is insecure. The configuration file also gives more control, for example it
supports multiple servers and multiple ways of detection of branch and module
names.

See L<kgb-client.conf(5)> for available configuration options. Unless noted
otherwise, all the options in the configuration file can also be used on
command line, prefixing them with two dashes. E.g. C<repo-id> becomes
C<--repo-id>

=head1 FAKE COMMIT MODE

If invoked with the B<--fake> option, B<kgb-client> will send a fake commit to
the servers. This is useful for testing client-server communication
independently from VCS setup.

=head1 MESSAGE RELAY MODE

When the B<--relay-msg> option is given, there is no repository to be
inspected. Instead, the non-option command line arguments are passed verbatim
to the bot to display on IRC. This can be used for real-time notification about
other events like bug submissions etc.

=head1 SUPPORTED VERSION CONTROL SYSTEMS

=head2 Subversion

Installation requires calling B<kgb-client> with two command line arguments,
like this:

    /path/to/kgb-client "$REPOS" "$REV"

=over

=item I<path to the subversion repository>

This is the physical path to the Subversion repository. Something like I</srv/svn/my-repo>

=item I<revision>

This is the revision number of the commit, that has triggered the hook.

=back

Both these arguments are supplied to the standard Subversion post-commit hooks.

=head2 Git

B<kgb-client> shall be installed as a B<post-receive> hook. Something along the
following shall do:

    #!/bin/sh
    /path/to/kgb-client --git-reflog - --conf /path/to.conf ...

B<--git-reflog -> will make B<kgb-client> read the reflog information from standard
input as any standard Git post-receive hook.

There are other ways to give kgb-client information about Git reflog, mostly
useful when debugging on in unusual situations. See L<App::KGB::Client::Git>.

=head2 CVS

B<kgb-client> shall be installed in the F<loginfo> file under CVSROOT in the
CVS repository. It shall be given two arguments -- the repository root, and the
directory in which the changes are being made.

For example:

    ALL /path/to/kgb-client --conf /path/to.conf ... "$CVSROOT" "%p"

=head1 SEE ALSO

=over

=item L<kgb-client.conf(5)>

=item L<App::KGB::Client>

=item L<App::KGB::Client::Subversion>

=item L<App::KGB::Client::Git>

=item L<App::KGB::Client::CVS>

=back

=cut

use App::KGB::Client::ServerRef;
use Getopt::Long;
use YAML ();

my ($conf_file,      $uri,        $proxy,
    $repo_id,        $password,   $timeout,
    $verbose,        $repo_type,  @br_mod_re, @mod_br_re,
    $br_mod_re_swap, $module,     $ignore_branch,
    @servers,        $git_reflog, $single_line_commits,
    $status_dir,     $web_link,   $short_url_service,
    $fake,           $protocol,   $relay_msg,
);
GetOptions(
    'conf=s'                     => \$conf_file,
    'uri=s'                      => \$uri,
    'proxy=s'                    => \$proxy,
    'repo-id=s'                  => \$repo_id,
    'pass|word=s'                => \$password,
    'timeout=s'                  => \$timeout,
    'branch-and-module-re=s'     => \@br_mod_re,
    'br-mod-re=s'                => \@br_mod_re,
    'module-and-branch-re=s'     => \@mod_br_re,
    'mod-br-re=s'                => \@mod_br_re,
    'branch-and-module-re-swap!' => \$br_mod_re_swap,
    'module=s'                   => \$module,
    'ignore-branch=s'            => \$ignore_branch,
    'repository=s'               => \$repo_type,
    'verbose!'                   => \$verbose,
    'git-reflog=s'               => \$git_reflog,
    'single-line-commits=s'      => \$single_line_commits,
    'status-dir=s'               => \$status_dir,
    'web-link=s'                 => \$web_link,
    'short-url-service=s'        => \$short_url_service,
    'fake!'                      => \$fake,
    'protocol=s'                 => \$protocol,
    'relay-msg',                 => \$relay_msg,
) or exit 1;

if( $conf_file )
{
    my $conf = YAML::LoadFile($conf_file)
        or die "Error loading config from $conf_file\n";

    $uri      ||= $conf->{uri};
    $proxy    ||= $conf->{proxy};
    $repo_id  ||= $conf->{'repo-id'};
    $password ||= $conf->{password};
    $timeout  ||= $conf->{timeout};
    @br_mod_re = @{ $conf->{'branch-and-module-re'} }
        if !@br_mod_re and $conf->{'branch-and-module-re'};
    @mod_br_re = @{ $conf->{'module-and-branch-re'} }
        if !@mod_br_re and $conf->{'module-and-branch-re'};
    $br_mod_re_swap //= $conf->{'branch-and-module-re-swap'};
    if ( $br_mod_re_swap ) {
        push @mod_br_re, @br_mod_re;
        @br_mod_re = ();
    }
    $ignore_branch //= $conf->{'ignore-branch'};
    $module //= $conf->{module};
    $repo_type //= $conf->{repository};
    $single_line_commits //= $conf->{'single-line-commits'};
    $status_dir //= $conf->{'status-dir'};
    $web_link //= $conf->{'web-link'};
    $short_url_service //= $conf->{'short-url-service'};
    $protocol //= $conf->{protocol};
    $relay_msg //= $conf->{relay_msg};

    @servers = map {
        App::KGB::Client::ServerRef->new(
            {   password => $password,
                timeout  => $timeout,
                verbose  => $verbose,
                %$_
            }
            )
        } @{ $conf->{servers} }
        if $conf->{servers};
}

push @servers,
    App::KGB::Client::ServerRef->new(
    {   uri      => $uri,
        password => $password,
        timeout  => $timeout,
        verbose  => $verbose,
    }
    ) if $uri;

die "no servers defined. use 'uri' or 'servers' configuration options\n"
    unless @servers;

die "repo-id not given\n" unless $repo_id;

$single_line_commits //= 'auto';

$single_line_commits =~ m/^(?:on|forced|auto)$/
    or die "Unknown value for the --single-line-commits option "
    . "('$single_line_commits')\n";

if ( $relay_msg ) {
    die "--relay-msg cannot be used together with --fake\n" if $fake;

    $repo_type = 'IGNORED';
    $relay_msg = join( ' ', @ARGV );
}

if ( not $repo_type ) {
    if ( exists $ENV{GIT_DIR} ) {
        die "Unable to determine repository type\n"
            . "both GIT_DIR and CVSROOT present in the environment.\n"
            . "Please use --repository to force repository type.\n"
            if exists $ENV{CVSROOT};

        $repo_type = 'git';
    }
    elsif ( exists $ENV{CVSROOT} ) {
        $repo_type = 'cvs';
    }
    else {
        $repo_type = 'svn';
    }
}

use Cwd();
use File::Spec;

if ( $repo_type eq 'git' and not $module and $ENV{GIT_DIR} ) {
    my @dirs = File::Spec->splitdir( Cwd::abs_path( $ENV{GIT_DIR} ) );
    pop @dirs if @dirs and $dirs[-1] eq '.git';
    $module = $dirs[-1];
    $module =~ s/\.git$// if $module;
}

my @client_args = (
    repo_id             => $repo_id,
    servers             => \@servers,
    br_mod_re           => \@br_mod_re,
    mod_br_re           => \@mod_br_re,
    module              => $module,
    ignore_branch       => $ignore_branch,
    verbose             => $verbose,
    single_line_commits => $single_line_commits,
    status_dir          => $status_dir,
    web_link            => $web_link,
    short_url_service   => $short_url_service,
    protocol            => $protocol,
);

push @client_args, ( relay_message => $relay_msg ) if $relay_msg;

if ($fake) {
    warn "Sending fake commit notification\n";

    require App::KGB::Client::Fake;

    my $client = App::KGB::Client::Fake->new( {@client_args} );
    $client->process();

    exit 0;
}

if ( $relay_msg ) {
    eval { require App::KGB::Client::RelayMsg; 1 }
        or die "Message relay support unavailable\n"
        . "Error loading App::KGB::Client::RelayMsg:\n"
        . $@;

    my $client = App::KGB::Client::RelayMsg->new( { @client_args } );
    $client->process;
}
elsif ( $repo_type eq 'svn' ) {
    my($path, $rev) = @ARGV;
    die "Repository path and revision must be given as arguments\n"
        unless $path and $rev;

    print "Processing r$rev of SVN repository $path\n"
        if $verbose;

    eval { require App::KGB::Client::Subversion; 1; }
        or die "Subversion support unavailable\n"
        . "Error loading App::KGB::Client::Subversion:\n"
        . $@;

    my $client = App::KGB::Client::Subversion->new(
        {   @client_args,
            repo_path      => $path,
            revision       => $rev,
        }
    );

    $client->process();
}
elsif ( $repo_type eq 'git' ) {
    print "Processing Git receive pack\n"
        if $verbose;

    eval { require App::KGB::Client::Git; 1; }
        or die "Git support unavailable\n"
        . "Error loading App::KGB::Client::Git:\n"
        . $@;

    my $client = App::KGB::Client::Git->new(
        { @client_args, reflog => $git_reflog } );

    $client->process();

}
elsif ( $repo_type eq 'cvs' ) {
    print "Processing CVS commit\n"
        if $verbose;

    eval { require App::KGB::Client::CVS; 1; }
        or die "CVS support unavailable\n"
        . "Error loading App::KGB::Client::CVS:\n"
        . $@;

    my $cvs_root = shift(@ARGV);
    my $dir = shift(@ARGV);
    my $client = App::KGB::Client::CVS->new(
        {   @client_args,
            cvs_root  => $cvs_root,
            author    => $ENV{USER},
            directory => $dir,
            files     => [@ARGV],
        }
    );

    $client->process();
}
else {
    die "Repository type '$repo_type' not supported\n";
}

